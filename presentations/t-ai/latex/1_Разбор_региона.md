---
title: "Разбор: тестовый регион + регион (1-й тур) ВсОШ по ИИ 2025/2026"
author: "Калашников Александр"
institute: "Wildberries & Russ, ФКН ВШЭ"
format:
  beamer:
    pdf-engine: xelatex
    aspectratio: 169
    fontsize: 9pt
    section-titles: true
    incremental: true
    include-in-header: ./xeheader.tex # Убедитесь, что путь к файлу верный
header-includes:
  - \newcommand{\bgimage}{./logo2.png} # Убедитесь, что путь к картинке верный
---

# План разбора

## Структура

::: {.nonincremental}
* **Карта задач** и распределение по темам
* **Тестовый вариант**: задачи 1–4
* **Регион**: задачи A–H
* **Приложения**: Реализация на C++ (RMSE, окружность)
:::

---

# Карта задач (Тест)

| Задача | Тема | Идея решения |
|---|---|---|
| **1** | Оптимизация | $\min_x \to \min_z \to \min_y$ |
| **2** | Марковские цепи | Расстояние Хэмминга, уравнение на $E$ |
| **3** | Мартингалы | Сохранение суммы сил, опциональная остановка |
| **4** | ML / Эвристики | OLS через суммы, swap-локальный поиск |

# Карта задач (Регион 1-4)

| Задача | Тема | Идея решения |
|---|---|---|
| **A** | Последовательности | $S_n = 2 S_{n-1}$, анализ степеней двойки |
| **B** | Линейная алгебра | Линейность сети $\Rightarrow$ базис векторов |
| **C** | Оценки (Gap) | Покрытие отрезков длины $0.25$ |
| **D** | Робастная регрессия | MAE $\Rightarrow$ медиана по группам $x=c$ |

# Карта задач (Регион 5-8)

| Задача | Тема | Идея решения |
|---|---|---|
| **E** | Геометрия | Центральная симметрия, доля площади |
| **F** | Строки / Марков | Система уравнений для суффиксов |
| **G** | Комбинаторика | Цепочки пересечений $\to$ Числа Фибоначчи |
| **H** | Геометрия + ML | Lift в 4D: $(x^2+y^2, x, y, 1)$ |

---

## Сводка по темам

Распределение задач по ключевым областям:

::: {.nonincremental}
* **Вероятность / Марков / Мартингалы**: 3 задачи
* **Линейная алгебра / Линейность**: 2 задачи
* **Комбинаторика / Дискретная математика**: 2 задачи
* **Геометрия / Классификация**: 2 задачи
* **Оптимизация / Матанализ**: 1 задача
* **ML-инженерия / Эвристики**: 1 задача
:::

---

# Тестовый этап

## Тест 1. Минимум функции

**Дано:**
$$
F(x,y,z)=y^{4}+2y^{2}+z^{4}+4z\cos x+4yz\sin x,
\quad x\in[0,2\pi),\ y,z\ge 0.
$$

. . .

**Шаг 1. Минимизация по $x$**

Фиксируем $y,z$. Преобразуем тригонометрическую часть:
$$
4z(\cos x+y\sin x)=4z\sqrt{1+y^{2}}\cos(x-\varphi), \quad \text{где } \varphi=\arctan(y).
$$

Минимум достигается, когда косинус равен $-1$:
$$
\min_x (\dots) = -4z\sqrt{1+y^2}.
$$

## Тест 1. Минимизация по $z$ и $y$

**Шаг 2. Минимизация по $z$**

Обозначим $r=\sqrt{1+y^2}$. Функция: $z^4 - 4rz$.
Условие экстремума ($F'_z = 0$):
$$
4z^3 - 4r = 0 \implies z = r^{1/3}.
$$
Подставляем $z$: значение минимума $-3r^{4/3}$.

. . .

**Шаг 3. Финал**

Осталось минимизировать по $y$:
$$
f(y) = y^4 + 2y^2 - 3(1+y^2)^{2/3}.
$$
Замена $t=y^2$. Анализ производной дает минимум в $t=0 \implies y=0$.
Отсюда $r=1, z=1, x=\pi$.

:::{.callout-note}
### Ответ
$$x+y+z = \pi + 0 + 1 \approx 4.141593$$
:::

---

## Тест 2. «Гипер-муравей» на кубе

**Идея:**
Состояние системы определяется только расстоянием Хэмминга $k \in \{0, \dots, 4\}$ до цели $(0000)$. Старт из $k=4$.

. . .

**Переходы:**
* К цели ($k \to k-1$): вероятность $k/4$.
* От цели ($k \to k+1$): вероятность $(4-k)/4$.

. . .

**Уравнения для матожидания $E_k$:**
$$
\begin{cases}
E_0 = 0 \\
E_k = 1 + \frac{k}{4}E_{k-1} + \frac{4-k}{4}E_{k+1}, & k=1,2,3 \\
E_4 = 1 + E_3
\end{cases}
$$

:::{.callout-note}
### Ответ
Решая систему, получаем $E_4 = 64/3 \approx 21.333333$.
:::

---

## Тест 3. Турнир гладиаторов

**Условие:**
Сила Тимофея $S_T$, сила Максима $S_M$. Сумма $S_T + S_M = 85$ постоянна.

**Процесс:**
В бою с силами $x$ и $y$:
* Тимофей побеждает с вер. $\frac{x}{x+y} \implies S_T' = S_T + y$.
* Максим побеждает с вер. $\frac{y}{x+y} \implies S_T' = S_T - x$.

. . .

**Мартингал:**
Матожидание силы Тимофея после боя:
$$
\mathbb{E}[S_T'] = S_T + y \cdot \frac{x}{x+y} - x \cdot \frac{y}{x+y} = S_T.
$$

:::{.callout-tip}
### Теорема об опциональной остановке
$$\mathbb{E}[S_T^{\text{start}}] = \mathbb{E}[S_T^{\text{end}}]$$
$$55 = 85 \cdot P(\text{Win}_T) + 0 \cdot P(\text{Win}_M)$$
:::

Отсюда $P(\text{Win}_T) = 55/85$, а искомая $P(\text{Win}_M) = 30/85 \approx 0.352941$.

---

## Тест 4. Взлом RMSE

**Задача:** Удалить $k$ точек так, чтобы ошибка линейной регрессии (RMSE) на оставшихся была **максимальной**.

**Инженерный подход (C++):**

1.  **Формула OLS за $O(1)$:**
    Пересчитываем коэффициенты $a, b$ и ошибку SSE, храня 5 сумм:
    $\sum x, \sum y, \sum x^2, \sum xy, \sum y^2$.
2.  **Эвристики инициализации:**
    * Sliding Window по отсортированному $X$.
    * Удаление точек с *минимальным* текущим остатком (оставляем выбросы).
3.  **Локальный поиск (Swap):**
    Жадная замена "удаленной" точки на "оставленную", если это растит ошибку.

*(Код разбит на слайды в конце презентации)*

---

# Региональный этап

## Регион A. Натуральные числа

**Условие:** $a_n = \sum_{i=1}^{n-1} a_i$ для $n \ge 3$.
Среди чисел есть $N = 123\dots123\dots$ (делится на большие степени двойки).

. . .

**Свойство суммы:**
$$
S_n = S_{n-1} + a_n = 2S_{n-1} \implies S_n = 2^{n-2}S_2 = 2^{n-2}(a_1+1).
$$
Любое число в последовательности (кроме первых) имеет вид $2^k(a_1+1)$.

. . .

**Решение:**
Нужно найти такие $a_1$, что $N = 2^k(a_1+1)$.
Перебираем $k$, пока $N$ делится на $2^k$.

:::{.callout-note}
### Пример ответа
$a_1 = N/2^k - 1$.
:::

---

## Регион B. Матрицы без активаций

**Инсайт:**
Нейросеть без нелинейностей — это просто **линейное преобразование** $T(x) = Ax$.
Функция: $f(x) = \text{clip}(Ax)$.

**Дано:**
$$
f\begin{pmatrix}-2\\3\end{pmatrix}=\begin{pmatrix}60\\40\\100\end{pmatrix}, \quad
f\begin{pmatrix}1\\3\end{pmatrix}=\begin{pmatrix}200\\50\\80\end{pmatrix}.
$$

. . .

**Решение:**
Разложим целевой вектор $(-7, 6)$ по базису из данных векторов:
$$
\begin{pmatrix}-7\\6\end{pmatrix} = 3 \cdot \begin{pmatrix}-2\\3\end{pmatrix} - 1 \cdot \begin{pmatrix}1\\3\end{pmatrix}.
$$
В силу линейности $T$:
$$
T_{\text{target}} = 3 \cdot \begin{pmatrix}60\\40\\100\end{pmatrix} - \begin{pmatrix}200\\50\\80\end{pmatrix} = \begin{pmatrix}-20\\70\\220\end{pmatrix}.
$$
После clip (обрезки в $[0, 255]$): **0 70 220**.

---

## Регион C. Среднее и медиана

**Задача:** Максимизировать разность $|\bar{x} - m|$ для 10 точек на $[0, 1]$ с ограничениями на плотность (gap $\ge 0.01$, покрытие $0.25$).

. . .

**Оптимальная конструкция:**
Нужно "утащить" среднее как можно дальше от медианы.
Медиана определяется 5-й и 6-й точками. Прижимаем левую половину точек к нулю, а правую — к единице, соблюдая минимальные зазоры.

**Конфигурация:**
$$
(0, 0.01, 0.02, 0.03, 0.04, \mathbf{0.05}, 0.30, 0.55, 0.80, 1.00)
$$
* Медиана $m \approx 0.045$
* Среднее $\bar{x} \approx 0.28$

:::{.callout-note}
### Ответ
Разность = 0.235
:::

---

## Регион D. MAE и робастность

**Задача:** $\min_{a,b} \sum |(ax_i+b) - y_i|$.

**Свойство медианы:**
Для набора чисел $z_1, \dots, z_k$ сумма модулей $\sum |c - z_i|$ минимальна, когда $c$ — **медиана** $z_i$.

. . .

**Алгоритм:**
1.  Сгруппировать точки с одинаковым $x$.
2.  Для каждого $x$ найти "идеальный интервал" предсказаний $[\hat{y}_{\min}, \hat{y}_{\max}]$ (это медиана $y$ при данном $x$).
3.  Проверить, существует ли прямая, которая проходит через **все** эти интервалы.
4.  Если да — ответ равен сумме минимумов по группам.

:::{.callout-note}
### Ответ
MAE = $17/7 \approx 2.428571$
:::

---

## Регион F. Строки (ML)

**Задача:** Мат. ожидание длины строки до первого вхождения "ML". Старт с "DS".

**Метод:**
Состояние = последняя буква (или суффикс, если паттерн длиннее).
Обозначим $E_X$ — ср. число шагов до цели, если последняя была $X$.

**Система:**
* Если $X \neq M$: $E_X = 1 + \sum P_{XY} E_Y$.
* Если $X = M$:
    * Выпало $L$ (победа): вклад $1 \cdot 0.5$.
    * Выпало $N$ (неудача): вклад $(1 + E_N) \cdot 0.5$.

:::{.callout-note}
### Ответ
Решая линейную систему: $14.416667$.
:::

---

## Регион H. Окружность и Линейность

**Идея (Kernel Trick):**
Разделение классов окружностью $(x-x_0)^2 + (y-y_0)^2 = R^2$ — это нелинейная задача в 2D.
Но это **линейная** задача в пространстве признаков 4D:
$$
w_0(x^2+y^2) + w_1 x + w_2 y + w_3 = 0
$$

. . .

**Алгоритм:**
1.  Сделать mapping: $p \to (x^2+y^2, x, y, 1)$.
2.  Обучить обычный линейный классификатор (перцептрон / SVM).
3.  Восстановить параметры окружности из весов $w$:
    $$
    x_0 = -\frac{w_1}{2w_0}, \quad y_0 = -\frac{w_2}{2w_0}, \quad R = \sqrt{x_0^2+y_0^2 - \frac{w_3}{w_0}}.
    $$

---

# Приложения (Код)

## RMSE: Структура и OLS за O(1)

\footnotesize
```cpp
// Вычисление SSE (Sum Squared Error) по накопленным суммам
// Позволяет делать пересчет ошибки за O(1) при смене точек
static inline double compute_sse(int n, double sx, double sy, 
                                 double sxx, double sxy, double syy) {
    if (n <= 2) return 0.0;
    double nd = n;
    // Дисперсия и ковариация
    double varx = sxx - sx * sx / nd;
    double cov  = sxy - sx * sy / nd;
    
    // Коэффициенты регрессии y = ax + b
    double a = (fabs(varx) < 1e-18) ? 0.0 : cov / varx;
    double b = sy / nd - a * sx / nd;
    
    // Итоговая ошибка
    double sse = syy + a*a*sxx + nd*b*b - 2*a*sxy - 2*b*sy + 2*a*b*sx;
    return (sse < 0 && sse > -1e-6) ? 0 : sse;
}

```

## RMSE: Локальный поиск (Swap)

\footnotesize

```cpp
// Основной цикл оптимизации
// kept_list - индексы оставленных точек, rem_list - удаленных
auto local_search = [&](vector<int>& kept, vector<int>& rem) -> double {
    // ... инициализация сумм (sx, sy...) по kept ...
    
    bool improved = true;
    while(improved && check_time()) {
        improved = false;
        // Пробуем заменить каждую оставленную точку на каждую удаленную
        for(int i = 0; i < kept.size(); i++) {
            for(int j = 0; j < rem.size(); j++) {
                // Быстрый пересчет SSE при обмене (swap)
                // Если ошибка выросла -> применяем обмен
                if (new_sse > cur_sse) {
                    apply_swap(i, j); 
                    cur_sse = new_sse;
                    improved = true;
                }
            }
        }
    }
    return cur_sse;
};

```

## RMSE: Стратегии инициализации

Для старта локального поиска генерируем несколько начальных состояний:

1. **Sliding Window:**
Сортируем точки по . Берем окна размером . Выбираем то, где "вариативность " максимальна (шумные данные).
2. **Max Residuals:**
Считаем регрессию по *всем* точкам. Оставляем  точек с самыми большими остатками (выбросы).
3. **Random:**
В случае нехватки времени добавляем случайные перемешивания (Random Swap).

---

## Circle: Перцептрон (Main Loop)

\footnotesize

```cpp
// Обучение линейного разделителя в пространстве (x^2+y^2, x, y, 1)
for (int it = 0; it < steps; it++) {
    shuffle(idx.begin(), idx.end(), rng);
    bool any_error = false;

    for (int ii : idx) {
        const Pt& p = a[ii];
        // Feature mapping
        double r2 = p.x*p.x + p.y*p.y;
        array<double,4> phi {r2, p.x, p.y, 1.0};

        // Скалярное произведение w * phi
        double score = w[0]*phi[0] + w[1]*phi[1] + w[2]*phi[2] + w[3];
        
        // Если знак неправильный (ошибка классификации)
        if ((double)p.lab * score <= 0.0) {
            // Update rule (SGD)
            for(int k=0; k<4; k++) 
                w[k] += learning_rate * p.lab * phi[k];
            any_error = true;
        }
    }
    if (!any_error) break; // Идеальное разделение найдено
}

```

## Circle: Восстановление параметров

\footnotesize

```cpp
// Преобразование весов гиперплоскости обратно в параметры круга
if (w[0] < 0) { // Нормализация знака
    for (auto &v : w) v = -v; 
}

double w0=w[0], w1=w[1], w2=w[2], w3=w[3];

// Формулы перехода
double x0 = -w1 / (2.0 * w0);
double y0 = -w2 / (2.0 * w0);
double R2 = x0*x0 + y0*y0 - (w3 / w0);

cout << x0 << " " << y0 << " " << sqrt(max(0.0, R2)) << endl;

```

---

# Итоги

## Takeaways

::: {.nonincremental}
1. **Линейность везде:** От простых сетей без активаций (Region B) до Kernel Trick (Region H).
2. **Математика ошибки:** MAE "любит" медиану, MSE — среднее.
3. **Сохранение инвариантов:** В вероятностных задачах ищите мартингалы или системы линейных уравнений.
4. **Алгоритмы:** Часто "жадные" эвристики с хорошей инициализацией (как в задаче RMSE) работают лучше сложной теории на коротких контестах.
:::