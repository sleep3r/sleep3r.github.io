---
title: "Олимпиадная математика: Теория и Разбор"
author: "Калашников Александр"
institute: "Wildberries & Russ, ФКН ВШЭ"
format:
  beamer:
    pdf-engine: xelatex
    aspectratio: 169
    fontsize: 9pt
    section-titles: true
    incremental: true
    include-in-header: ./xeheader.tex
header-includes:
  - \newcommand{\bgimage}{./logo2.png}
---

# 1. Три главных инструмента олимпиадника

## Зачем это нужно?

Олимпиадная математика — это не школьная программа на стероидах. Это набор **мощных мыслительных инструментов**, которые позволяют решать задачи, не поддающиеся перебору.

::: {.nonincremental}
Сегодня мы разберём **3 фундаментальных метода**:

1. **Инварианты и моноварианты** — законы сохранения в задачах
2. **Математическая индукция** — сведение сложного к простому
3. **Рекуррентные соотношения** — формулы для последовательностей
:::

. . .

> Каждый инструмент мы сначала изучим на простых примерах, а потом **обкатаем на реальных олимпиадных задачах**.

---

# 2. Инварианты: Законы сохранения

## Что такое инвариант?

**Инвариант** — это величина, которая **не меняется** при выполнении допустимых операций.

. . .

**Пример из жизни:** В шахматах слон всегда стоит на клетке одного цвета. Цвет клетки — это инвариант.

. . .

Формально: если система переходит из состояния $S_t$ в $S_{t+1}$, и существует функция $I$ такая, что $I(S_{t+1}) = I(S_t)$ **всегда**, то $I$ — инвариант.

. . .

**Главная теорема:** Если $I(S_{\text{start}}) \neq I(S_{\text{цель}})$, то цель **недостижима**.

## Разминка: 10 серверов

**Задача.** В дата-центре 10 серверов, на них суммарно 55 Тб данных. За одну операцию: сливаем 2 сервера в 1, при этом 1 Тб дубликатов удаляется, пустой сервер гасится. Сколько Тб останется на последнем сервере?

. . .

::: {.nonincremental}
**Решение.** Следим за двумя величинами:
- Объём данных $S$ — каждый шаг уменьшается на 1
- Число серверов $N$ — каждый шаг уменьшается на 1

Значит, разность $S - N$ **не меняется** — это инвариант!
:::

. . .

$$S - N = 55 - 10 = 45 = \text{const}$$

В финале: $N = 1$, значит $S = 45 + 1 = 46$ Тб.

## Типы инвариантов

::: {.nonincremental}
1. **Чётность.** Самый частый. Если операция сохраняет чётность суммы, а в начале сумма чётная, а в конце должна быть нечётной — невозможно!
2. **Остатки по модулю.** Обобщение чётности: следим за остатком от деления на 3, 4, ...
3. **Квадратичные формы.** Если система симметрична, проверяйте $x^2 + y^2 + z^2$.
4. **Графовые инварианты.** Число рёбер в графе, число компонент связности...
:::

## Моноварианты (полуинварианты)

**Моновариант** — величина, которая строго **убывает** (или возрастает) на каждом шаге.

. . .

Если моновариант ограничен снизу (например, $f(S) \geq 0$), то процесс **обязательно остановится**.

. . .

**Пример:** Градиентный спуск в ML — функция потерь (Loss) уменьшается на каждом шаге обучения. Она ограничена снизу нулём. Значит, алгоритм сходится.

. . .

> Инвариант $\Rightarrow$ «невозможно дойти». Моновариант $\Rightarrow$ «обязательно дойдём».

---

# 3. Индукция: Сведение к меньшей задаче

## Метод математической индукции

Хотим доказать утверждение $P(n)$ для всех натуральных $n$.

::: {.nonincremental}
**Два шага:**

1. **База:** Доказываем $P(1)$ (или $P(n_0)$ для начального значения).
2. **Переход:** Предполагаем, что $P(k)$ верно (**индуктивное предположение**), и из этого выводим $P(k+1)$.
:::

. . .

Это как домино: если первая костяшка упала и каждая следующая роняет соседнюю — все упадут.

## Индукция в играх

В олимпиадных задачах на стратегии индукция — **главное оружие**.

. . .

**Идея:** Не рисуем гигантское дерево вариантов на $N$ элементов! Вместо этого:

::: {.nonincremental}
1. Ищем **доминирующий первый ход** — действие, которое изолирует 1 элемент
2. Оставшаяся игра на $N-1$ элементах — **по предположению уже решена**
3. Комбинируем и получаем стратегию для $N$
:::

. . .

> Дерево игры имеет размер $O(2^N)$ или $O(N!)$. Индукция сжимает его до $N$ шагов.

## Пример: Adversarial Feature Selection

**Задача.** Модель пуста. Атакующий банит множества фичей (отличные от полного набора $n$). Защитник добавляет/удаляет по 1 фиче. Модель не должна совпадать с бан-листами. Цель: собрать все $n$ фичей. Кто выиграет?

. . .

**Ответ:** Защитник выигрывает.

## Доказательство (индукция по $n$)

**База $n=1$:** Бан-лист — пустое множество. Защитник добавляет фичу. Победа.

. . .

**Переход $n-1 \to n$:**
Атакующий банит множество $M$. Раз $M \neq \{1, \ldots, n\}$, то $\exists\, f \notin M$.

. . .

::: {.nonincremental}
- Защитник первым ходом добавляет $f$ и **никогда её не удаляет**
- Все будущие бан-листы **без** $f$: модель содержит $f$, совпадения не будет — ок!
- Все бан-листы **с** $f$: вычитаем $f$ отовсюду. Получаем точно такую же игру на $n-1$ фичах
- По предположению индукции, Защитник умеет выигрывать на $n-1$.
:::

---

# 4. Рекуррентные соотношения

## Что такое рекуррента?

**Рекуррентное соотношение** — формула, выражающая $n$-й член последовательности через предыдущие.

::: {.nonincremental}
- $a_n = a_{n-1} + a_{n-2}$ — числа Фибоначчи
- $a_n = 2a_{n-1}$ — геометрическая прогрессия
- $a_n = a \cdot a_{n-1} + b \cdot a_{n-2}$ — линейная рекуррента 2-го порядка
:::

. . .

**Зачем это?** В огромном числе олимпиадных задач (вероятности, комбинаторика, игры) состояние на шаге $n$ зависит только от предыдущих. Составили рекурренту — решили задачу.

## Характеристическое уравнение (университетский путь)

Для рекурренты $x_n = a x_{n-1} + b x_{n-2}$ подставляем $x_n = \lambda^n$:

$$\lambda^2 - a\lambda - b = 0$$

. . .

Корни $\lambda_1, \lambda_2$ дают общее решение:
$$x_n = C_1 \lambda_1^n + C_2 \lambda_2^n$$

Константы $C_1, C_2$ находим из начальных условий.

. . .

> Но для олимпиады есть путь **проще и элегантнее** — без матриц и собственных значений!

## Хакерский трюк: Метод сдвигов

**Ключевая идея:** превратить рекурренту 2-го порядка в две рекурренты 1-го порядка (геометрические прогрессии).

. . .

Ищем число $c$ такое, что:
$$x_n + c \cdot x_{n-1} = \lambda(x_{n-1} + c \cdot x_{n-2})$$

. . .

Раскрываем скобки: $x_n = (\lambda - c)x_{n-1} + \lambda c \cdot x_{n-2}$.

Сравниваем с $x_n = a x_{n-1} + b x_{n-2}$:

::: {.nonincremental}
1. $\lambda - c = a$, значит $\lambda = a + c$
2. $\lambda c = b$, подставляем: $c(a+c) = b$, то есть $c^2 + ac - b = 0$
:::

. . .

Это **то же самое** характеристическое уравнение, только для $c$!

## Алгоритм решения рекуррент (без матриц)

::: {.nonincremental}
1. Из рекурренты $x_n = ax_{n-1} + bx_{n-2}$ составляем $c^2 + ac - b = 0$
2. Находим корень $c$. Тогда $\lambda = a + c$
3. Величина $y_n = x_n + c \cdot x_{n-1}$ — геометрическая прогрессия с множителем $\lambda$
4. Решаем $x_n + c \cdot x_{n-1} = y_n$ (это уже 1-й порядок!)
5. Для решения 1-го порядка используем **метод неподвижной точки**
:::

. . .

> Сейчас обкатаем это на двух задачах.

---

# 5. Задача: Маршрутизация по кольцу

## Условие

Кольцевая топология: серверы A, B, C. Пакет стартует в C. На каждом шаге случайно пересылается на одного из двух соседей. Сколько маршрутов длины 239 возвращают пакет обратно в C?

## Составляем рекурренту

Обозначим:

::: {.nonincremental}
- $a_n$ — число путей в C за $n$ шагов
- $b_n$ — число путей в A (= число путей в B, по симметрии)
:::

. . .

Из C можно пойти в A или B, из A можно пойти в C или B:
$$a_n = 2b_{n-1}, \qquad b_n = b_{n-1} + a_{n-1}$$

. . .

Подставляем одно в другое:
$$a_{n+1} = 2b_n = 2(b_{n-1} + a_{n-1}) = a_n + 2a_{n-1}$$

Начальные условия: $a_0 = 1$ (уже в C), $a_1 = 0$ (за 1 шаг не вернуться).

## Трюк 1: Сворачиваем сумму

Прибавим $a_n$ к обеим частям уравнения $a_{n+1} = a_n + 2a_{n-1}$:

$$a_{n+1} + a_n = 2a_n + 2a_{n-1} = 2(a_n + a_{n-1})$$

. . .

Обозначим $S_n = a_n + a_{n-1}$. Тогда:
$$S_{n+1} = 2S_n$$

. . .

Это **геометрическая прогрессия**! При $S_1 = a_1 + a_0 = 0 + 1 = 1$:
$$S_n = 2^{n-1}$$

. . .

Мы понизили порядок: $a_n + a_{n-1} = 2^{n-1}$.

## Трюк 2: Неподвижная точка

Делим обе части на $2^n$. Замена $x_n = a_n / 2^n$:
$$x_n + \frac{1}{2}x_{n-1} = \frac{1}{2} \implies x_n = \frac{1}{2} - \frac{1}{2}x_{n-1}$$

. . .

Ищем неподвижную точку: $X = \frac{1}{2} - \frac{1}{2}X \implies X = \frac{1}{3}$.

. . .

Вычитаем $\frac{1}{3}$: 
$$x_n - \frac{1}{3} = -\frac{1}{2}\left(x_{n-1} - \frac{1}{3}\right)$$

Геометрическая прогрессия со знаменателем $-\frac{1}{2}$!

## Финальный ответ

$$x_n - \frac{1}{3} = \left(x_0 - \frac{1}{3}\right)\left(-\frac{1}{2}\right)^n = \frac{2}{3}\left(-\frac{1}{2}\right)^n$$

. . .

Возвращаемся к $a_n$:
$$\boxed{a_n = \frac{2^n + 2(-1)^n}{3}}$$

. . .

При $n = 239$ (нечётное, $(-1)^{239} = -1$):

:::{.callout-note}
### Ответ
$a_{239} = \dfrac{2^{239} - 2}{3}$
:::

---

# 6. Задача: Стохастический парсер

## Условие

Генератор выдаёт $+1$ или $+2$ (каждое с вероятностью $\frac{1}{2}$). Выпавшее число прибавляется к текущей сумме (стартуем с 0). Найти вероятность того, что сумма **когда-нибудь** станет в точности равна 2024.

## Составляем рекурренту

Пусть $p_n$ — вероятность когда-нибудь попасть ровно в число $n$.

. . .

Как мы могли оказаться в $n$? Только двумя способами:

::: {.nonincremental}
- Были в $n-1$ и выбросили $+1$
- Были в $n-2$ и выбросили $+2$
:::

. . .

$$p_n = \frac{1}{2}p_{n-1} + \frac{1}{2}p_{n-2}$$

Начальные условия: $p_0 = 1$ (мы уже тут), $p_1 = \frac{1}{2}$ (только один способ).

## Находим инвариант

Прибавим $\frac{1}{2}p_{n-1}$ к обеим частям:
$$p_n + \frac{1}{2}p_{n-1} = p_{n-1} + \frac{1}{2}p_{n-2}$$

. . .

**Стоп!** Левая часть для шага $n$ совпадает с правой частью для шага $n-1$. Это **инвариант**, он вообще не меняется!

. . .

Считаем для $n=1$: $p_1 + \frac{1}{2}p_0 = \frac{1}{2} + \frac{1}{2} = 1$.

Значит для **любого** $n$:
$$p_n + \frac{1}{2}p_{n-1} = 1 \implies p_n = 1 - \frac{1}{2}p_{n-1}$$

## Метод неподвижной точки

$$p_n = 1 - \frac{1}{2}p_{n-1}$$

. . .

Неподвижная точка: $X = 1 - \frac{1}{2}X \implies X = \frac{2}{3}$.

. . .

Вычитаем $\frac{2}{3}$:
$$p_n - \frac{2}{3} = -\frac{1}{2}\left(p_{n-1} - \frac{2}{3}\right)$$

. . .

Геометрическая прогрессия:
$$p_n = \frac{2}{3} + \frac{1}{3}\left(-\frac{1}{2}\right)^n$$

. . .

При $n = 2024$ (чётное, минус сгорает):

:::{.callout-note}
### Ответ
$p_{2024} = \dfrac{2}{3} + \dfrac{1}{3 \cdot 2^{2024}}$
:::

---

# 7. Практика: Задачи на инварианты

## Задача: Жадный балансировщик

В дата-центре 3 кластера с батчами данных. Балансировщик переносит по 1 батчу. Его **награда** за перенос = (размер кластера КУДА) $-$ (размер кластера ОТКУДА до переноса). В итоге размеры кластеров вернулись к начальным. Какова максимальная суммарная награда?

. . .

**Подсказка:** Попробуйте отследить сумму квадратов размеров.

## Решение: Алгебраический инвариант

Шаг: берём батч из кучи размера $x$, кладём в кучу размера $y$. Награда $\Delta S = y - (x - 1)$.

. . .

Новая сумма квадратов: $(x-1)^2 + (y+1)^2 + z^2$:
$$= (x^2 + y^2 + z^2) + 2(y - x + 1) = \sum x_i^2 + 2\Delta S$$

. . .

Значит: $\sum x_i^2 - 2S$ — **инвариант**!

. . .

Раз в конце сумма квадратов вернулась к начальной $\implies 2S = 0$.

:::{.callout-note}
### Ответ
Максимальная суммарная награда = **0**, независимо от действий.
:::

## Альтернатива: Графовое доказательство

::: {.nonincremental}
- Представим батчи как вершины графа. Батчи в одном кластере — полный граф (клика)
- Перенос батча из кластера $A+1$ в кластер $B$: разрывается $A$ рёбер, создаётся $B$ рёбер
- Изменение числа рёбер: $\Delta E = B - A$
- Это **в точности** награда за шаг!
:::

. . .

Суммарная награда $= \Delta E_{\text{total}}$. Состояние вернулось к начальному $\implies \Delta E_{\text{total}} = 0$.

. . .

> Два разных доказательства одного факта. Алгебра и графы дают один ответ — красота!

---

# 8. Задача: Принцип Дирихле

## Условие: Распределённый ансамбль

В ансамбле 1000 ML-моделей. Модель либо «надёжная» (говорит правду), либо «скомпрометированная» (лжёт). За сессию **каждая** модель **каждой** отправила диагностику: «Твой статус — скомпрометированная!». Модели могли уходить в ребут (меняя статус). Найти **наименьшее** число ребутов за сессию.

. . .

**Ключевое наблюдение:** Модель A скажет модели B «ты скомпрометированная» тогда и только тогда, когда **у них разные статусы**.

## Решение

Предположим, что 3 модели ни разу не ребутались. Статусов всего 2.

. . .

По **принципу Дирихле**: среди 3 моделей минимум 2 имеют одинаковый статус всё время.

. . .

Но тогда они **не смогли бы** отправить друг другу фразу «ты скомпрометированная» (одинаковые статусы)! Противоречие.

. . .

Значит, без ребута обошлись максимум **2 модели**.

:::{.callout-note}
### Ответ
Минимум ребутов: $1000 - 2 = 998$.
:::

---

# 9. Задача: Бегущий кабан

## Условие

Мишень в 1 из 100 закрытых окон. Если мы стреляем в окно с мишенью — поражаем. После каждого выстрела выжившая мишень сдвигается на 1 окно вправо (из 100-го не сдвигается). Найти минимум выстрелов, гарантирующий поражение.

## Стратегия: стреляем через одно

Кабан каждый ход меняет чётность позиции. Стреляем по нечётным: $1, 3, 5, \ldots, 99$.

::: {.nonincremental}
- Это 50 выстрелов
- Кабан бежит вправо, мы «гоним» его
- После 50 выстрелов выживший кабан зажат в 100-м окне
- **51-й контрольный** выстрел в окно 100
:::

. . .

**Но почему нельзя быстрее?**

## Доказательство минимальности (оценка снизу)

Мысленно сажаем **100 кабанов** во все окна.

::: {.nonincremental}
- 1 выстрел убивает максимум 1 кабана (в окне $< 100$)
- Пусть мы делаем $k$ выстрелов по окнам $< 100$ + финальный в 100-е
- Кабан из окна $i$ достигнет 100-го за $100-i$ шагов
- Кабаны с $i < 99-k$ не доберутся до 100 за $k+1$ шагов
- Их нужно убить нашими $k$ выстрелами: $k \geq 98-k$, т.е. $k \geq 49$
:::

. . .

При $k=49$ кабан из окна 1 за 50 ходов дойдёт только до 51-го — не хватит!

:::{.callout-note}
### Ответ
$k = 50$, всего **51 выстрел**.
:::

---

# 10. Резюме и чек-лист

## Что мы изучили

::: {.nonincremental}
1. **Инварианты** — величина, которая не меняется. Если старт $\neq$ цель по инварианту — цель недостижима. (Чётность, остатки, квадраты, рёбра графа)
2. **Моноварианты** — величина, которая строго убывает/возрастает. Если ограничена — процесс конечен
3. **Индукция** — доказываем для $n=1$, потом из $k$ выводим $k+1$. В играх: изолируем элемент, сводим к $n-1$
4. **Рекурренты** — выражаем шаг через предыдущие. Решаем трюком сдвигов: находим $c$, сворачиваем в геометрическую прогрессию, затем неподвижная точка
5. **Принцип Дирихле** — если $n+1$ объектов распределить по $n$ ящикам, хотя бы в одном окажется $\geq 2$
:::

## Алгоритм атаки на олимпиадную задачу

::: {.nonincremental}
1. **Прочитай условие 3 раза.** Первый — общий смысл. Второй — формализация. Третий — ограничения
2. **Проверь инварианты.** Чётность? Остаток по модулю? Сумма квадратов?
3. **Попробуй индукцию.** Можно ли свести $n$ к $n-1$? Есть ли доминирующий первый ход?
4. **Составь рекурренту** для вероятностных / комбинаторных задач
5. **Если модель вернулась в начальное состояние** — сумма изменений $= 0$
6. **Оценка + пример.** Доказать, что лучше нельзя — такая же задача, как найти оптимум
:::

. . .

> Ищите скрытые закономерности. За страшными деревьями вариантов всегда лежат красивые прогрессии и законы сохранения.
